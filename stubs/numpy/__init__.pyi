# pylint: skip-file

from typing import Any, Generic, Iterator, Literal, Sequence, TypeVar, TypeVarTuple, overload

from numpy import linalg as linalg

DType = TypeVar("DType")
DType2 = TypeVar("DType2")
Shape = TypeVarTuple("Shape")
Dim1 = TypeVar("Dim1")
Dim2 = TypeVar("Dim2")
Dim3 = TypeVar("Dim3")

class ndarray(Generic[DType, *Shape]):
    def __and__(self: ndarray[bool, *Shape], other: ndarray[bool, *Shape]) -> ndarray[bool, *Shape]: ...
    def __invert__(self: ndarray[bool, *Shape]) -> ndarray[bool, *Shape]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: DType) -> ndarray[bool, *Shape]: ...
    def __ior__(self: ndarray[bool, *Shape], other: ndarray[bool, *Shape]) -> ndarray[bool, *Shape]: ...
    @overload
    def __ge__(self, other: DType) -> ndarray[bool, *Shape]: ...
    @overload
    def __ge__(self: ndarray[int, *Shape], other: float) -> ndarray[bool, *Shape]: ...
    def __add__(self, other: ndarray[DType, *Shape]) -> ndarray[DType, *Shape]: ...
    def __sub__(self, other: ndarray[DType, *Shape]) -> ndarray[DType, *Shape]: ...
    def __rsub__(self, other: DType) -> ndarray[DType, *Shape]: ...
    @overload
    def __mul__(self, other: DType) -> ndarray[DType, *Shape]: ...
    @overload
    def __mul__(self, other: ndarray[DType, *Shape]) -> ndarray[DType, *Shape]: ...
    def astype(self, dtype: type[DType2]) -> ndarray[DType2, *Shape]: ...
    @overload
    def __getitem__(self: ndarray[DType, Dim1], key: int) -> DType: ...
    @overload
    def __getitem__(
        self: ndarray[DType, Dim1, Dim2], key: tuple[ndarray[int, Dim3], slice]
    ) -> ndarray[DType, Any, Dim2]: ...
    @overload
    def __getitem__(self: ndarray[DType, Dim1], key: tuple[slice, None]) -> ndarray[DType, Dim1, Any]: ...
    @overload
    def __getitem__(
        self: ndarray[DType, Dim1, Dim2], key: tuple[ndarray[bool, Dim1], slice]
    ) -> ndarray[DType, Any, Dim2]: ...
    @overload
    def __getitem__(self: ndarray[DType, Dim1, Dim2], key: tuple[slice, int]) -> ndarray[DType, Dim1]: ...
    @overload
    def __getitem__(self: ndarray[DType, Dim1, Dim2], key: tuple[int, int]) -> DType: ...
    @overload
    def __getitem__(self: ndarray[DType, Dim1], key: slice) -> ndarray[DType, Dim1]: ...
    def __setitem__(self, key: slice, value: ndarray[DType, *Shape]) -> None: ...
    def __iter__(self) -> Iterator[DType]: ...
    @property
    def shape(self: ndarray[DType, Dim1, Dim2]) -> tuple[int, int]: ...
    def tolist(self: ndarray[DType, Dim1]) -> list[DType]: ...
    def reshape(
        self: ndarray[DType, Dim1], shape: tuple[Literal[-1], Literal[1]]
    ) -> ndarray[DType, Dim1, Literal[1]]: ...
    size: int

class integer:
    def __int__(self) -> int: ...

class signedinteger(integer): ...

class int64(signedinteger):
    def __init__(self, value: int | str) -> None: ...

Scalar = TypeVar("Scalar", int, float)

@overload
def percentile(a: ndarray[float, *Shape] | ndarray[int, *Shape], q: float) -> float: ...
@overload
def percentile(
    a: ndarray[float | int, *Shape] | ndarray[int, *Shape], q: ndarray[float, Dim1]
) -> ndarray[float, Dim1]: ...
@overload
def array(object: Sequence[ndarray[DType, *Shape]]) -> ndarray[DType, Any, *Shape]: ...
@overload
def array(object: Sequence[Scalar]) -> ndarray[Scalar, Any]: ...
@overload
def array(object: Sequence[tuple[float, ...]]) -> ndarray[float, Any, Any]: ...
def clip(a: ndarray[float, *Shape], a_min: float, a_max: float) -> ndarray[float, *Shape]: ...
def floor(x: ndarray[float, *Shape]) -> ndarray[float, *Shape]: ...
def ceil(x: ndarray[float, *Shape]) -> ndarray[float, *Shape]: ...
@overload
def mean(a: ndarray[float, Dim1, *Shape], axis: Literal[0]) -> ndarray[float, *Shape]: ...
@overload
def mean(a: ndarray[float, Dim1, Dim2, *Shape], axis: Literal[1]) -> ndarray[float, Dim1, *Shape]: ...
@overload
def mean(a: ndarray[bool, Dim1, Dim2, *Shape], axis: Literal[1]) -> ndarray[float, Dim1, *Shape]: ...
@overload
def mean(a: ndarray[int, Dim1, Dim2, *Shape], axis: Literal[1]) -> ndarray[float, Dim1, *Shape]: ...
def arange(stop: int, dtype: type[DType]) -> ndarray[DType, Any]: ...
def insert(
    arr: ndarray[DType, Dim1, Dim2], obj: int, values: ndarray[DType, Dim1], axis: Literal[1]
) -> ndarray[DType, Dim1, Dim2]: ...
def vstack(tup: Sequence[ndarray[DType, *Shape]]) -> ndarray[DType, *Shape]: ...
@overload
def cumsum(a: ndarray[DType, Dim1]) -> ndarray[DType, Dim1]: ...
@overload
def cumsum(a: Sequence[DType]) -> ndarray[DType, Any]: ...
def vsplit(
    ary: ndarray[DType, *Shape], indices_or_sections: ndarray[int, Any]
) -> list[ndarray[DType, *Shape]]: ...
def linspace(start: float, stop: float, num: int) -> ndarray[float, Any]: ...
def zeros(shape: int, dtype: type[DType]) -> ndarray[DType, Any]: ...
def nonzero(a: ndarray[bool, Dim1]) -> tuple[ndarray[int, Dim1]]: ...
def argmin(a: Sequence[DType]) -> int: ...
def where(condition: ndarray[bool, Dim1], x: DType, y: DType) -> ndarray[DType, Dim1]: ...

newaxis: None
